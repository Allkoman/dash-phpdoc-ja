<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="content-type" content="text/html; CHARSET=shift-jis">
  <title>タイミング攻撃に対して安全な文字列比較</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link media="all" rel="stylesheet" type="text/css" href="style.css"/>
 </head>
 <body class="docs"><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.hash-copy.html">hash_copy</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.hash-file.html">hash_file</a></div>
 <div class="up"><a href="ref.hash.html">Hash 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div><hr /><div id="function.hash-equals" class="refentry">
 <div class="refnamediv">
  <h1 class="refname">hash_equals</h1>
  <p class="verinfo">(PHP 5 &gt;= 5.6.0, PHP 7)</p><p class="refpurpose"><span class="refname">hash_equals</span> &mdash; <span class="dc-title">タイミング攻撃に対して安全な文字列比較</span></p>

 </div>

 <div class="refsect1 description" id="refsect1-function.hash-equals-description">
  <h3 class="title">説明</h3>
  <div class="methodsynopsis dc-description">
   <span class="type">bool</span> <span class="methodname"><strong>hash_equals</strong></span>
    ( <span class="methodparam"><span class="type">string</span> <code class="parameter">$known_string</code></span>
   , <span class="methodparam"><span class="type">string</span> <code class="parameter">$user_string</code></span>
   )</div>

  <p class="para rdfs-comment">
   2つの文字列が等しいかどうか、同じ長さの時間で比較します。
  </p>
  <p class="para">
   この関数は、タイミング攻撃を緩和するために使われるべきです。
   たとえば <span class="function"><a href="function.crypt.html" class="function">crypt()</a></span> によるパスワードのハッシュを検証する場合などです。
  </p>
 </div>


 <div class="refsect1 parameters" id="refsect1-function.hash-equals-parameters">
  <h3 class="title">パラメータ</h3>
  <dl>

   
    <dt>
<code class="parameter">known_string</code></dt>

    <dd>

     <p class="para">
       比較対象とする既知の長さの<span class="type"><span class="type 文字列">文字列</span></span>
     </p>
    </dd>

   
   
    <dt>
<code class="parameter">user_string</code></dt>

    <dd>

     <p class="para">
      ユーザー指定の文字列
     </p>
    </dd>

   
  </dl>

 </div>


 <div class="refsect1 returnvalues" id="refsect1-function.hash-equals-returnvalues">
  <h3 class="title">返り値</h3>
  <p class="para">
    2つの文字列が等しい場合は <strong><code>TRUE</code></strong> を返し、そうでない場合は <strong><code>FALSE</code></strong> を返します。
  </p>
 </div>


 <div class="refsect1 errors" id="refsect1-function.hash-equals-errors">
  <h3 class="title">エラー / 例外</h3>
  <p class="para">
   指定されたパラメータのいずれかが文字列でない場合、
   <strong><code>E_WARNING</code></strong> メッセージを出力します。
  </p>
 </div>


 <div class="refsect1 examples" id="refsect1-function.hash-equals-examples">
  <h3 class="title">例</h3>
  <p class="para">
   <div class="example" id="example-912">
    <p><strong>例1 <span class="function"><strong>hash_equals()</strong></span> の例</strong></p>
    <div class="example-contents">
<div class="phpcode"><code><span style="color: #000000">
<span style="color: #0000BB">&lt;?php<br />$expected&nbsp;&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'12345'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$2a$07$usesomesillystringforsalt$'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$correct&nbsp;&nbsp;&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'12345'</span><span style="color: #007700">,&nbsp;</span><span style="color: #DD0000">'$2a$07$usesomesillystringforsalt$'</span><span style="color: #007700">);<br /></span><span style="color: #0000BB">$incorrect&nbsp;</span><span style="color: #007700">=&nbsp;</span><span style="color: #0000BB">crypt</span><span style="color: #007700">(</span><span style="color: #DD0000">'apple'</span><span style="color: #007700">,&nbsp;&nbsp;</span><span style="color: #DD0000">'$2a$07$usesomesillystringforsalt$'</span><span style="color: #007700">);<br /><br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">hash_equals</span><span style="color: #007700">(</span><span style="color: #0000BB">$expected</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$correct</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">var_dump</span><span style="color: #007700">(</span><span style="color: #0000BB">hash_equals</span><span style="color: #007700">(</span><span style="color: #0000BB">$expected</span><span style="color: #007700">,&nbsp;</span><span style="color: #0000BB">$incorrect</span><span style="color: #007700">));<br /></span><span style="color: #0000BB">?&gt;</span>
</span>
</code></div>
    </div>

    <div class="example-contents"><p>上の例の出力は以下となります。</p></div>
    <div class="example-contents screen">
<div class="cdata"><pre>
bool(true)
bool(false)
</pre></div>
    </div>
   </div>
  </p>
 </div>


 <div class="refsect1 notes" id="refsect1-function.hash-equals-notes">
  <h3 class="title">注意</h3>
  <blockquote class="note"><p><strong class="note">注意</strong>: 
   <p class="para">
    正しく比較するには、両方の引数が同じ長さでなければなりません。
    異なる長さの引数を与えた場合、 <strong><code>FALSE</code></strong> が直ちに返され、
    タイミング攻撃を加えられていると、既知の文字列の長さが漏れる可能性があります。
   </p>
  </p></blockquote>
  <blockquote class="note"><p><strong class="note">注意</strong>: 
   <p class="para">
    ユーザー指定の文字列を、最初ではなく2番目のパラメーターとして指定することが重要です。
   </p>
  </p></blockquote>
 </div>


</div><div id="usernotes">
 <div class="head">
  <h3 class="title">User Contributed Notes</h3>
 </div>
<div id="allnotes">  <a name="121508""></a>
  <div class="note">
   <strong class="user">enclaved</strong>
   <a href="#121508" class="date">11-Aug-2017 05:10</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
This is a WARNING to everyone!<br />
<br />
Using hash_equals() is fine in itself, but the NEED for such comparison isn't, and should be an alarm to you that your PHP program design is severely flawed somewhere. The golden rule has it: NEVER do any sort of crypto in PHP in the first place. Cryptography doesn't belong in PHP code for a variety of reasons.<br />
<br />
First of all, it is a very sloppy and insecure enterprise; I keep seeing script kiddos trying to roll their own crypto again and again without a iota of understanding. Homemade crypto appliance is worse than no crypto, it is pure vice. If you're not a professional, well-educated, experienced cryptographer, then forget about writing your own crypto code forever, don't even dare to consider it before you master the subject in every tiny aspect, because you WILL make mistakes. Dangerous, fatal mistakes. To add insult to injury, in PHP security flaws may be exceptionally non-obvious due to the complexity of Zend--the chances are there will always be a side channel attack opportunity, and you'll never figure it out, because your code MAY appear bug-less, but some internal aspect of the Zend framework still opens a side channel attack vector. Remember: crypto does not belong in scripting languages because of their very misleading and unpredictable nature (in terms of cryptographic environments); crypto must be written in solid, compiled, purely deterministic languages like C, C++, and Fortran.<br />
<br />
Second, PHP is neither the right tool nor the right environment for cryptography. In a typical site system, PHP is not in place to do crypto, because there are better places to do it: the HTTP server and the RDBMS. Just memorize this single rule of thumb: cryptographic secrets must never cross subsystem/layer boundaries:<br />
<br />
&nbsp;&nbsp;&nbsp; Database &lt;-- ! --&gt; CGI program &lt;-- ! --&gt; HTTP server<br />
<br />
Cryptographic tasks are performed either by the HTTP server (e.g. authentication of users with client SSL certificates) or the RDBMS (e.g. password-based access to data), and these tasks must be ENCAPSULATED inside the facility, self-contained. For example, if you store KDF-derived digests of passwords in an SQL database, you must NOT compare digests in PHP, but only in SQL queries or stored procedures. Once produced and put into the database, a password digest (or any other sensitive data) must not exit it in any way as-is, be it a SELECT query or some other way, that is considered a leak in the cryptosystem. Use ONLY database-provided means to perform any crypto operations.<br />
<br />
As PostgreSQL is the usual database of choice for technically advanced and sound WWW or intranet sites, my advice is to use its pgcrypto extension, it is mature, well-tested, and has all the right tools. Here's a textbook password handling example to illustrate how secrets can be confined within the database layer without extracting them into the PHP layer. Password digest derivation and storing:<br />
<br />
&nbsp;&nbsp;&nbsp; INSERT INTO account (digest) VALUES (crypt('password', gen_salt('bf')));<br />
<br />
Verification:<br />
<br />
&nbsp;&nbsp;&nbsp; SELECT digest = crypt('password', gen_salt(digest)) FROM account;<br />
<br />
Exceptionally simple, elegant, clean, and secure (Blowfish is more than enough for user-set passwords), isn't it? You can clearly see that after the initial INSERT (or any subsequent UPDATEs) the password digest never leaves the RDBMS, that is, never gets trasmitted in any form over the client-server link, the entire checking procedure is wholly executed by the RDBMS, i.e. it is encapsulated and isolated. And the best part about it: no PHP involved in crypto! This IS the way to go if application security is on your checklist.<br />
<br />
The SELECT query above performs password checking without disclosing the digest it is comparing against, which is exactly my point. It would be illogical, impractical, and just stupid to use hash_equals() in this scenario when the RDBMS itself can do just fine.</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="119576""></a>
  <div class="note">
   <strong class="user">s rotondo90 at gmail com</strong>
   <a href="#119576" class="date">11-Jul-2016 01:00</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
asphp has done a great job and that one of Markus P. N. is also good too.<br />
<br />
However i made my own more concise version of the asphp code that supports different lenght strings and i used the same tests of Markus in order see how it works.<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'hash_equals'</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">hash_equals</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">, </span><span class="default">$user_string</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">) !== </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$user_string</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string </span><span class="keyword">= </span><span class="default">$known_string</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">$known_string </span><span class="keyword">^ </span><span class="default">$user_string</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">) - </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;= </span><span class="default">0</span><span class="keyword">; --</span><span class="default">$i</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">|= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; <br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return !</span><span class="default">$ret</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="118384""></a>
  <div class="note">
   <strong class="user">David Grudl</strong>
   <a href="#118384" class="date">26-Nov-2015 02:55</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Very short timing attack safe string comparison for PHP &lt; 5.6<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">function </span><span class="default">hash_equals</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; return </span><span class="default">substr_count</span><span class="keyword">(</span><span class="default">$a </span><span class="keyword">^ </span><span class="default">$b</span><span class="keyword">, </span><span class="string">"\0"</span><span class="keyword">) * </span><span class="default">2 </span><span class="keyword">=== </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$a </span><span class="keyword">. </span><span class="default">$b</span><span class="keyword">);<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="117101""></a>
  <div class="note">
   <strong class="user">Cedric Van Bockhaven</strong>
   <a href="#117101" class="date">15-Apr-2015 06:01</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
Our server does not support the hash_equals function. We are using the following snippet which also has support for strings of different length:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'hash_equals'</span><span class="keyword">)) {<br />
&nbsp;&nbsp;&nbsp; function </span><span class="default">hash_equals</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">, </span><span class="default">$b</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$a</span><span class="keyword">) ^ </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$b</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">|= </span><span class="default">array_sum</span><span class="keyword">(</span><span class="default">unpack</span><span class="keyword">(</span><span class="string">"C*"</span><span class="keyword">, </span><span class="default">$a</span><span class="keyword">^</span><span class="default">$b</span><span class="keyword">));<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return !</span><span class="default">$ret</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115664""></a>
  <div class="note">
   <strong class="user">Markus P. N.</strong>
   <a href="#115664" class="date">05-Sep-2014 06:46</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
I don't know why asphp at dsgml dot com got that many downvotes, the function seems to work.<br />
<br />
I extended it a bit to support strings of diffent length and to handle errors and ran some tests:<br />
<br />
The test results and how to reproduce them: <a href="http://pastebin.com/mLMXJeva" rel="nofollow" target="_blank">http://pastebin.com/mLMXJeva</a><br />
<br />
The function:<br />
<span class="default">&lt;?php<br />
<br />
</span><span class="keyword">if (!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'hash_equals'</span><span class="keyword">)) {<br />
<br />
&nbsp;&nbsp;&nbsp; </span><span class="comment">/**<br />
&nbsp;&nbsp; &nbsp; * Timing attack safe string comparison<br />
&nbsp;&nbsp; &nbsp; * <br />
&nbsp;&nbsp; &nbsp; * Compares two strings using the same time whether they're equal or not.<br />
&nbsp;&nbsp; &nbsp; * This function should be used to mitigate timing attacks; for instance, when testing crypt() password hashes.<br />
&nbsp;&nbsp; &nbsp; * <br />
&nbsp;&nbsp; &nbsp; * @param string $known_string The string of known length to compare against<br />
&nbsp;&nbsp; &nbsp; * @param string $user_string The user-supplied string<br />
&nbsp;&nbsp; &nbsp; * @return boolean Returns TRUE when the two strings are equal, FALSE otherwise.<br />
&nbsp;&nbsp; &nbsp; */<br />
&nbsp;&nbsp;&nbsp; </span><span class="keyword">function </span><span class="default">hash_equals</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">, </span><span class="default">$user_string</span><span class="keyword">)<br />
&nbsp;&nbsp;&nbsp; {<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">func_num_args</span><span class="keyword">() !== </span><span class="default">2</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// handle wrong parameter count as the native implentation<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="string">'hash_equals() expects exactly 2 parameters, ' </span><span class="keyword">. </span><span class="default">func_num_args</span><span class="keyword">() . </span><span class="string">' given'</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">null</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">) !== </span><span class="default">true</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="string">'hash_equals(): Expected known_string to be a string, ' </span><span class="keyword">. </span><span class="default">gettype</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">) . </span><span class="string">' given'</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$known_string_len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$known_string</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string_type_error </span><span class="keyword">= </span><span class="string">'hash_equals(): Expected user_string to be a string, ' </span><span class="keyword">. </span><span class="default">gettype</span><span class="keyword">(</span><span class="default">$user_string</span><span class="keyword">) . </span><span class="string">' given'</span><span class="keyword">; </span><span class="comment">// prepare wrong type error message now to reduce the impact of string concatenation and the gettype call<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">if (</span><span class="default">is_string</span><span class="keyword">(</span><span class="default">$user_string</span><span class="keyword">) !== </span><span class="default">true</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">trigger_error</span><span class="keyword">(</span><span class="default">$user_string_type_error</span><span class="keyword">, </span><span class="default">E_USER_WARNING</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="comment">// prevention of timing attacks might be still possible if we handle $user_string as a string of diffent length (the trigger_error() call increases the execution time a bit)<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string_len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$user_string</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string_len </span><span class="keyword">= </span><span class="default">$known_string_len </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string_len </span><span class="keyword">= </span><span class="default">$known_string_len </span><span class="keyword">+ </span><span class="default">1</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$user_string_len </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$user_string</span><span class="keyword">);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; if (</span><span class="default">$known_string_len </span><span class="keyword">!== </span><span class="default">$user_string_len</span><span class="keyword">) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">$known_string </span><span class="keyword">^ </span><span class="default">$known_string</span><span class="keyword">; </span><span class="comment">// use $known_string instead of $user_string to handle strings of diffrent length.<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">1</span><span class="keyword">; </span><span class="comment">// set $ret to 1 to make sure false is returned<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; </span><span class="keyword">} else {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">$known_string </span><span class="keyword">^ </span><span class="default">$user_string</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; for (</span><span class="default">$i </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">) - </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">--) {<br />
&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">|= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; }<br />
&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; return </span><span class="default">$ret </span><span class="keyword">=== </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
<br />
}<br />
<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
  <a name="115635""></a>
  <div class="note">
   <strong class="user">asphp at dsgml dot com</strong>
   <a href="#115635" class="date">29-Aug-2014 04:48</a>
   <div class="text">
    <div class="phpcode">
<code><span class="html">
To transparently support this function on older versions of PHP use this:<br />
<br />
<span class="default">&lt;?php<br />
</span><span class="keyword">if(!</span><span class="default">function_exists</span><span class="keyword">(</span><span class="string">'hash_equals'</span><span class="keyword">)) {<br />
&nbsp; function </span><span class="default">hash_equals</span><span class="keyword">(</span><span class="default">$str1</span><span class="keyword">, </span><span class="default">$str2</span><span class="keyword">) {<br />
&nbsp;&nbsp;&nbsp; if(</span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str1</span><span class="keyword">) != </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$str2</span><span class="keyword">)) {<br />
&nbsp;&nbsp; &nbsp;&nbsp; return </span><span class="default">false</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; } else {<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$res </span><span class="keyword">= </span><span class="default">$str1 </span><span class="keyword">^ </span><span class="default">$str2</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; </span><span class="default">$ret </span><span class="keyword">= </span><span class="default">0</span><span class="keyword">;<br />
&nbsp;&nbsp; &nbsp;&nbsp; for(</span><span class="default">$i </span><span class="keyword">= </span><span class="default">strlen</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">) - </span><span class="default">1</span><span class="keyword">; </span><span class="default">$i </span><span class="keyword">&gt;= </span><span class="default">0</span><span class="keyword">; </span><span class="default">$i</span><span class="keyword">--) </span><span class="default">$ret </span><span class="keyword">|= </span><span class="default">ord</span><span class="keyword">(</span><span class="default">$res</span><span class="keyword">[</span><span class="default">$i</span><span class="keyword">]);<br />
&nbsp;&nbsp; &nbsp;&nbsp; return !</span><span class="default">$ret</span><span class="keyword">;<br />
&nbsp;&nbsp;&nbsp; }<br />
&nbsp; }<br />
}<br />
</span><span class="default">?&gt;</span>
</span>
</code>
    </div>
   </div>
  </div>
 <div class="foot"></div>
</div>
</div>
<hr /><div class="manualnavbar" style="text-align: center;">
 <div class="prev" style="text-align: left; float: left;"><a href="function.hash-copy.html">hash_copy</a></div>
 <div class="next" style="text-align: right; float: right;"><a href="function.hash-file.html">hash_file</a></div>
 <div class="up"><a href="ref.hash.html">Hash 関数</a></div>
 <div class="home"><a href="index.html">PHP Manual</a></div>
</div></body></html>
